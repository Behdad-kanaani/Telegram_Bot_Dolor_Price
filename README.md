# 📊 سیستم پایش و اعلان قیمت‌های لحظه‌ای بازار

این پروژه یک معماری کامل و پایدار برای پایش خودکار قیمت‌های لحظه‌ای دارایی‌های مالی (طلا، دلار، تتر) از وب‌سایت‌های مختلف و ارسال هوشمندانه تغییرات آن‌ها به یک کانال یا گروه تلگرامی است.  
برای تضمین پایداری و دور زدن محدودیت‌های احتمالی، از یک **Cloudflare Worker** به‌عنوان پروکسی امن و کارآمد استفاده می‌شود.

> ⚠️ **توجه**: این پروژه صرفاً جهت نمایش معماری و روش کار طراحی شده است.  
> لینک‌های وب‌سایت‌ها در کد پایتون به‌صورت تستی و با استفاده از مکان‌های نگهدارنده (Placeholder) نمایش داده شده‌اند.  
> برای استفاده در محیط واقعی، باید لینک‌های معتبر و مورد تأیید خود را جایگزین کنید.

---

## ✨ ویژگی‌های برجسته پروژه

- 📈 **پایش در زمان واقعی**  
  اسکریپت پایتون به‌صورت خودکار و منظم، در بازه‌های زمانی قابل تنظیم، وب‌سایت‌های هدف را اسکرپ کرده و داده‌های لحظه‌ای را استخراج می‌کند.

- 🔔 **اعلان هوشمند**  
  با مقایسه قیمت‌های جدید با مقادیر قبلی، تغییرات قیمت تشخیص داده شده و با اموجی‌های رنگی:  
  🟢 افزایش | 🔴 کاهش | ⚪ ثبات  
  به تلگرام ارسال می‌شوند.

- 🔒 **پروکسی امن Cloudflare Worker**  
  به‌عنوان یک لایه میانی، درخواست‌های HTTP را امن و پایدار ارسال کرده و محدودیت‌های جغرافیایی را دور می‌زند.

- 🛡️ **لایه‌های امنیتی چندگانه**
  - **احراز هویت با توکن**: فقط درخواست‌های معتبر پذیرفته می‌شوند.
  - **لیست سفید دامنه‌ها (Whitelist)**: Worker تنها به دامنه‌های مجاز متصل می‌شود.

- ⚙️ **طراحی ماژولار**  
  پروژه به دو بخش مجزا (Worker و اسکریپت پایتون) تقسیم شده که نگهداری و توسعه را ساده‌تر می‌کند.

---

## 🗺️ معماری سیستم

سیستم بر اساس دو جزء اصلی ساخته شده است:

1. **Cloudflare Worker (دروازه امن پروکسی)**  
   درخواست‌ها را اعتبارسنجی کرده و به مقصد هدایت می‌کند.

2. **اسکریپت پایتون (موتور اصلی)**  
   مسئول اسکرپینگ، تحلیل داده‌ها و ارسال اعلان‌ها به تلگرام است.

### نحوه کارکرد

- اسکریپت پایتون درخواست‌های خود را به Worker ارسال می‌کند.  
- Worker پس از تأیید هویت، آن‌ها را به وب‌سایت‌های هدف یا API تلگرام هدایت می‌کند.  
- پاسخ دریافتی دوباره به پایتون بازگردانده می‌شود.

![معماری پروژه](https://i.ibb.co/v4b24gG/architecture.png)

---

## 💻 تحلیل فنی و توضیحات کدها

### 1. Cloudflare Worker (`cloudflare.js`) ☁️

- نقطه ورود اصلی:

  ```js
  export default {
    async fetch(request) {
      // ...
    }
  }

* **احراز هویت با SECRET\_TOKEN**

  ```js
  const SECRET_TOKEN = "myStrongSecret123";
  const token = request.headers.get("x-access-token");
  if (token !== SECRET_TOKEN) {
      return new Response("Unauthorized: Invalid or missing token", { status: 401 });
  }
  ```

* **لیست سفید دامنه‌ها**
  اجازه دسترسی فقط به دامنه‌های مجاز.

* **مدیریت زمان و منابع**
  استفاده از `AbortController` برای timeout ۱۵ ثانیه‌ای.

---

### 2. اسکریپت پایتون (`main.py`) 🐍

* **تنظیمات اولیه**
  شامل `WORKER_URL`, `WORKER_TOKEN`, `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID`.

* **دیکشنری `SCRAPE_TARGETS`**
  نقشه وب‌سایت‌ها و دارایی‌ها.

* **توابع کلیدی**

  * `send_telegram_message_via_worker`: ارسال پیام به تلگرام از طریق Worker.
  * `scrape_price`: استخراج قیمت‌ها با BeautifulSoup.

* **حلقه اصلی (`while True`)**
  اجرای منظم پایش و اعلان بر اساس بازه تنظیم‌شده.

---

## 🚀 راهنمای نصب و راه‌اندازی

### 1. راه‌اندازی Cloudflare Worker ☁️

* ورود به پنل Cloudflare > بخش **Workers & Pages**
* ایجاد Worker جدید و جای‌گذاری کد `cloudflare.js`
* تنظیم مقدار امن برای `SECRET_TOKEN`
* Deploy و کپی کردن URL Worker

---

### 2. تنظیم اسکریپت پایتون 🐍

* نصب پیش‌نیازها:

  ```bash
  pip install requests beautifulsoup4
  ```

* ویرایش فایل `main.py` و تنظیم مقادیر:

  * `WORKER_URL`
  * `WORKER_TOKEN`
  * `TELEGRAM_BOT_TOKEN`
  * `TELEGRAM_CHAT_ID`

* جایگزینی لینک‌های واقعی در `SCRAPE_TARGETS`

---

### 3. اجرای پروژه ▶️

```bash
python main.py
```

### اجرای دائمی روی سرور ♾️

```bash
nohup python main.py &
```

---

## 🛡️ ملاحظات امنیتی

* توکن‌ها را هرگز در مخزن عمومی منتشر نکنید.
  از **متغیرهای محیطی** استفاده کنید.

* دامنه‌های مجاز را در `allowedHosts` محدود کنید.

---

## 🤝 مشارکت و پشتیبانی

اگر سوال یا پیشنهادی دارید، لطفاً یک **Issue** جدید در همین مخزن باز کنید.
مشارکت شما باعث بهبود پروژه خواهد شد.

---

اگر بخواهی، نمونه فایل‌های کد کامل `cloudflare.js` و `main.py` را هم اضافه کنم داخل README تا دسترسی مستقیم به کد هم داشته باشند؟  
یا فقط همین توضیحات و راهنما کفایت می‌کند؟
